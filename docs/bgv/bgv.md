# Brakerski, Gentry and Vaikuntanathan (BGV) Scheme

## Introduction

The model of computation suitable for homomorphic encryption is not
a Turing machine, but a (combinational) boolean or arithmetic
circuits. Circuits, however, are rigid objects with predetermined
number of input parameters (a.k.a wires), output parameters and
intermediate gates. For example, a (combinational) circuit designed
to run a SQL query over a database of 10,000 records will not be
able to handle a database with 10,001 records! For that, one will
need a _new circuit_ that can handle 10,001 input "wires"! Ideally,
one would like an FHE scheme where the ciphertexts and the FHE
parameters associated with that ciphertext are independent of the
circuit being evaluated. Gentry, in his original Ph.D. thesis
defined a generic technique called bootstrapping that decouples the
size of the ciphertext from the size of the circuit. The basic idea
is to fix the FHE scheme's parameters in such a way that the scheme
can correctly evaluate its own decryption circuit plus at least one
more multiplication and addition. Further details about
bootstrapping can be found in the
[Appendix](../appendix/bootstrapping.md).

Bootstrapping however comes at a severe computational cost since
each multiplication must be followed by bootstrapping operations. A
somewhat cheaper option is to fix the maximum depth of the circuit
and select parameters that only guarantees _correct decryption_ up
to that depth. (Note: This is only a correctness requirement --- the
security of the system should still be independent of circuit depth.
In particular, if an adversary feeds the ciphertext through a longer
depth circuit to cause decryption failure and uses decryption
failure as an oracle to recover plaintext/secret-key, then such a
scheme cannot be considered secure.) FHE schemes that can handle
pre-defined circuit depths are called **leveled** fully homomorphic
encryption scheme.

BGV, is a leveled fully homomorphic encryption scheme. It is based
on _generalized learning with errors_ problem (which includes LWE,
Ring-LWE, and module-LWE problem), but in this post, we restrict the
discussion to Ring-LWE over a $2^k$-cyclotomic ring.

## Notation

For a positive integer $m$, we denote by $\ZZ_m$ the quotient ring
$\Zmod{m}$, i.e., the ring of integers modulo $m$. We denote by
$\ZZ_m^*$ the group of units in $\ZZ_m$, i.e., those elements in
$\ZZ_m$ that have a multiplicative inverse.  Therefore, by
definition, $|\ZZ_m^*| = \phi(m)$, where $\phi$ is the Euler's
totient function.

For a positive integer $m$, we define the set of non-negative
integers less than $m$ using the $\range{\cdot}$ operator as

$$
\range{m} := \{0, 1, 2, \cdots, (m-1) \}
$$

Note that $\range{m}$ is only a set, and is different from $\ZZ_m =
\{m\ZZ, 1 + m\ZZ, \cdots, (m-1) + m\ZZ \}$. (Unlike $\ZZ_m$,
$\range{m}$ is not even closed under addition.)


Recall that $\ZZ_m$ is an _equivalence class_ of integers as far as
algebraic operations are concerned. That is, for every element
$\bar{x} \in \ZZ_m$, if we pick two different integer
representatives $\alpha$ and $\beta$ of $\bar{x}$, i.e., $\alpha$
and $\beta$ are such that $\bar{x} := \alpha + m\ZZ$ and also
$\bar{x} := \beta + m\ZZ$, then _for all_ polynomials $f(x) \in
\ZZ[x]$, $f(\alpha) \equiv f(\beta)\; (\text{mod}\, m)$. This
equivalence, however, is limited to algebraic operations only â€” it's
not an equivalence relation for transcendental operations, e.g.,
$\log(\alpha) \neq \log(\beta)\; (\text{mod}\, m)$ in general.
Indeed, $\log_2(\alpha)$, which is the minimum number of bits needed
to represent $\alpha$ in base $2$, will usually not be equal to
$\log_2(\beta)$.

In order to select a concrete representative of $x \in \ZZ_m$, as
well as to define $m$-ary lattice generated by modulo reduction, we
define $\lift{x}_m$ as the numerically-least residue of $x$, i.e,
$\lift{x}_m$ is an **integer** $y$ such that $-\frac{m}{2} < y \leq
\frac{m}{2}$ **and** $x \equiv y\;(\text{mod}\, m$).

More formally,

$$
\begin{aligned}
\lift{\cdot}_m &: \ZZ_m \rightarrow \ZZ \\
\lift{x}_m &= \begin{cases}
y & \text{if} & \exists y \in \{x + m\ZZ\}\;\text{s.t.}\; 0 \leq y \leq \frac{m}{2} \\
y - m  & \text{otherwise} & \text{i.e., when}\, y \in \{x + m\ZZ\}\;
\text{and}\; (\frac{m}{2} < y < m) \end{cases} \end{aligned} $$

In other words, $\lift{x}_m$ is the integer remainder when $x$ is
divided by $m$ and adjusted to fall within the range $(-\frac{m}{2},
\frac{m}{2}]$.

??? example

    Consider the ring $\ZZ_7$. Let $x := 11 + 7\ZZ \in \ZZ_7$, then

    $$
    \lift{11}_7 = 4 - 7 = -3 \in \ZZ
    $$

    since $y = 4$ satisfies the _otherwise_ case: $(4 \in  11 + 7\ZZ) \wedge (\frac{7}{2} < 4 < 7)$.

Let $\vec{a}(X) = \sum a_iX^i \in (\Zmod{q})[X]$ be a polynomial. We
extend the definition of $\lift{\cdot}_q$ to polynomials as

$$
\begin{aligned}
  \lift{\cdot}_q &: (\Zmod{q})[X] \rightarrow \ZZ[X]\\
  \lift{\sum a_iX^i}_q &= \sum \lift{a_i}_q X^i
\end{aligned}
$$

### Probability Distributions

Let $\mathcal{D}$ be a probability distribution defined over a set
$R$, which can be discrete or continuous, finite of infinite. We use
the notation

$$
x \xleftarrow{\mathcal{D}} R
$$

to mean a random sample $x$ drawn according to the distribution
$\mathcal{D}$ over $R$. For example $x \xleftarrow{\mathsf{DGS}}
\ZZ$ means $x$ is drawn from a discrete gaussian distribution (DGS)
over integers. When $R$ is _discrete and finite_, the symbol ${\$}$
means a uniform distribution. For example, $x \xleftarrow{\$}
 (\Zmod{6})$ means $x$ is drawn uniformly at random from $(\Zmod{6})
 \cap \{0, 1,\cdots, 5\}$.


### Roots of Unity and Cyclotomic Polynomials

Let $m$ be an integer and $k$ be either $\QQ$ or $\mathbb{F}_{p^h}\;
(p \in \PRIMES, h\in \ZZ_{> 0})$.
An element $\omega$ in the algebraic closure $\bar{k}$ of $k$, is
called an $m$-th **root of unity** if $\omega^m = 1$. In other
words, $\omega$ is a root of the equation $f(x) = X^m -1 \in
 \bar{k}[X]$. Let

$$
\Omega_m^k := \{\omega_1, \omega_2, \cdots \}
$$

be the set of all _distinct_ roots of the equation $X^m = 1$ in
$\bar{k}$. Since $X^m-1$ can have at most $m$ roots,
$\norm{\Omega_m^k} \leq m$. When $k = \QQ$ or $\mathbb{F}_{p^h}$
with $p \nmid m$, $X^m - 1$ is separable and $X^m -1$ has exactly
$m$ root, therefore $\norm{\Omega_m^k} = m$. When $p \mid m$, say $m
= p^\alpha\cdot l$ (with $p \nmid l$) then

$$
  X^m - 1 =  X^{p^\alpha l} - 1 = (X^l-1)^{p^\alpha} \implies (X^l-1)
  = 0
$$

has $l$ distinct roots and $\norm{\Omega_m^k} = l$.

??? abstract "Lemma: $\left(\Omega_m^k, \times\right)$ is a finite group"

    - **Identity**: Since $1$ is always a root of $X^m - 1$, $1 \in \Omega_m^k$.

    - **Closure**: Let $\omega_1, \omega_2 \in \Omega_m^k$. Then $1 = 1\cdot 1 = (\omega_1)^m (\omega_2)^m = (\omega_1\cdot\omega_2)^m \implies \omega_1\cdot\omega_2 \in \Omega_m^k.$

    - **Inverse**: Let $\omega \in \Omega_m^k$ and let $s$ be a
    positive integer. Then $1 = 1^s = \left(\omega^m\right)^s = \left(\omega^s\right)^m$
    $\implies$ $\omega^s$ is also an $m$-th root of unity -- by definition.
    If we set $s = m-1$, then $\omega^{m-1}$ must also be an $m$-th root of unity.
    In other words, $\forall \omega, \omega^{m-1} \in \Omega_m^k$ and
    $\omega\cdot\omega^{m-1} = 1.$


??? abstract  "Lemma: $\left(\Omega_m^k, \times\right)$ is cyclic"

    Let $h := \norm{\Omega_m^k}$ be the order of $\Omega_m^k$, i.e.,
    $h = m$ or $h = l$ if $m = p^\alpha l$. Let $\norm{\omega}$
    denote the order of $\omega \in \Omega_m^k$.

    Let $\mathcal{D} := \{ d : d | h \}$ be the set of all factors
    of  $h$. For each $d \in \mathcal{D}$, let $\mathcal{A}_d$ be the
    set of elements of $\Omega_m^k$ whose order is $d$, i.e.,

    $$
      \mathcal{A}_d := \{ \omega \in \Omega_m^k : \norm{\omega} = d \}
    $$

    Suppose $\mathcal{A}_d$ is not empty, and let $\omega \in \mathcal{A}_d$.
    Consider the subgroup of $d$-th roots of unity, i.e., $\Omega_d^k$. By definition,
    $\omega$ is element of $\Omega_d^k$ and so is every element of the
    cyclic subgroup $\langle \omega \rangle$ generated by $\omega$. Therefore

    $$
      \langle \omega \rangle \subseteq \Omega_d^k
    $$

    However, $\norm{\langle \omega \rangle} = d$ and $\norm{\Omega_d^k} = d$
    therefore $\langle \omega \rangle = \Omega_d^k$. That means
    every element of $\mathcal{A}_d$ is a generator of $d$-th root of unity.
    Since there are $\phi(d)$ generators of a cyclic subgroup,

    $$
      \norm{\mathcal{A}_d} = \phi(d).
    $$

    To prove that $\Omega_d^k$ is cyclic, if we can show that
     $\norm{\Omega_h^k} = \sum_{d \mid h} \norm{\mathcal{A}_d}$ then
     that would mean that elements of  $\mathcal{A}_h$ generate
     $\Omega_h^k$. But this is immediate, since
     $\sum_{d \mid h} \norm{\mathcal{A}_d} = \sum_{d \mid h} \phi(d) = h$.

    $\mathhdr{}$ Proof run-through

    Let $k = \QQ$ and consider the $12$th roots of unity
    $\Omega_{12}^{\QQ} := \{1, e^{2\pi\vec{i}\frac{1}{12}}, e^{2\pi\vec{i}\frac{2}{12}}, \cdots, e^{2\pi\vec{i}\frac{11}{12}} \}$. Then $\mathcal{D} := \{1, 2, 3, 4, 6, 12 \}$,

    $$
      \begin{aligned}
        \mathcal{A}_1 &:= \{ 1 \} \\
        \mathcal{A}_2 &:= \{ e^{2\pi\vec{i}\frac{6}{12}} \} \\
        \mathcal{A}_3 &:= \{ e^{2\pi\vec{i}\frac{4}{12}}, e^{2\pi\vec{i}\frac{8}{12}} \}  \\
        \mathcal{A}_4 &:= \{ e^{2\pi\vec{i}\frac{3}{12}}, e^{2\pi\vec{i}\frac{9}{12}} \} \\
        \mathcal{A}_6 &:= \{ e^{2\pi\vec{i}\frac{2}{12}}, e^{2\pi\vec{i}\frac{10}{12}} \} \\
        \mathcal{A}_{12} &:= \{ e^{2\pi\vec{i}\frac{1}{12}}, e^{2\pi\vec{i}\frac{5}{12}}, e^{2\pi\vec{i}\frac{7}{12}}, e^{2\pi\vec{i}\frac{11}{12}} \} \\
      \end{aligned}
    $$

    and

    $$
      \begin{aligned}
        \Omega_1^k &:= \{ 1 \} \\
        \Omega_2^k &:= \{ 1, e^{2\pi\vec{i}\frac{1}{2}} \} \\
        \Omega_3^k &:= \{ 1, e^{2\pi\vec{i}\frac{1}{3}}, e^{2\pi\vec{i}\frac{2}{3}} \}  \\
        \Omega_4^k &:= \{ 1 , e^{2\pi\vec{i}\frac{1}{4}}, e^{2\pi\vec{i}\frac{2}{4}}, e^{2\pi\vec{i}\frac{3}{4}},\} \\
        \Omega_6^k &:= \{ 1 , e^{2\pi\vec{i}\frac{1}{6}}, e^{2\pi\vec{i}\frac{2}{6}}, e^{2\pi\vec{i}\frac{3}{6}}, e^{2\pi\vec{i}\frac{4}{6}}, e^{2\pi\vec{i}\frac{5}{6}}\} \\
        \Omega_{12}^k &:= \{ 1 , e^{2\pi\vec{i}\frac{1}{12}}, \cdots, e^{2\pi\vec{i}\frac{11}{12}}\} \\
      \end{aligned}
    $$

    And notice that if we pick $\omega = e^{2\pi\vec{i}\frac{10}{12}}$
    from $\mathcal{A}_6$, then the cyclic group

    $$
      \left \langle e^{2\pi\vec{i}\frac{10}{12}} \right \rangle = \{ e^{2\pi\vec{i}\frac{5}{6}}, e^{2\pi\vec{i}\frac{4}{6}}, e^{2\pi\vec{i}\frac{3}{6}}, e^{2\pi\vec{i}\frac{2}{6}}, e^{2\pi\vec{i}\frac{1}{6}}, 1 \} = \Omega_6^k.
    $$

    Similarly, $\omega = e^{2\pi\vec{i}\frac{2}{12}}$ is the
    other element in $\mathcal{A}_6$ and also generates the same
    set $\Omega_6^k$ (verify), validating the claim that
    $\norm{\mathcal{A}_6} = \phi(6) = 2.$

    $\mathftr$

Since $(\Omega_m^{k}, \times)$ is cyclic, we call the generators of
this group the **primitive** $m$-th roots of unity and denote this
set by $\Omega_m^\times \subseteq \Omega_m^k$. Let $\omega \in
\Omega_m^\times$ be a _primitive_ $m$-th root. Then, there exists a
natural group homomorphism $h_\omega$ between $(\ZZ_m, +)$ and
$(\Omega_m^{k}, \times)$ give by

$$
  \begin{aligned}
  g_\omega &: \ZZ_m \rightarrow \Omega_m^\times \\
  g_\omega(i) &= \omega^i.
  \end{aligned}
$$

Since $\omega$ is primitive and generates the entire group, $g$ is a
finite injective map, and therefore bijective. Furthermore, for
every $i$ co-prime to $m$, $\norm{\omega^i} = \norm{\omega}$, and
therefore $\omega^i$ is also primitive. In other words, there's a
bijection between $\ZZ_m^*$ and $\Omega_m^\times$.

Let $\Phi_m(X)$ be a polynomial whose roots are _primitive_ $m$-th
roots of unity, i.e.,

$$
  \Phi_m(X) := \prod_{\omega \in \Omega_m^\times} (X - \omega).
$$

$\Phi_m(X)$ is called the **$m$-th cyclotomic polynomial**. A-priori,
we know that $\Phi_m(X)$ is a monoic polynomial, whose coefficients
are in $\bar{k}$. However, when $k=\QQ$, its well known that

- $\Phi_m(X)$ has all its coefficients contained in $\ZZ$, i.e.,
  $\Phi_m(X) \in \ZZ[X]$, and
- $\Phi_m(X)$ is irreducible over $\QQ$.

The following formula are also well known:

$$
  X^m - 1 = \prod_{d | m} \Phi_d(X).
$$

## BGV encryption scheme

The BGV encryption scheme is based on decisional (Ring)-LWE
assumption, and is similar to a scheme proposed by Regev in
[Reg05][^Reg05] and [Reg10][^Reg10].

Let $\Phi_m(X)$ be the $m$-th cyclotomic polynomial of degree $n =
\phi(m)$. Let $q, p \in \ZZ$ be the ciphertext and plaintext modulus
respectively, with  $q \gg p$ and $q, p \in \poly{n}$. Let
$\bar{\Phi}_m$ denote the image of $\Phi_m$ modulo some prime.

Let

$$
\begin{aligned}
R &:= \ZZ[Y]\large /\langle \Phi_m(Y)\rangle \\
R_q &:= \ZZ[Y]\large/\langle \Phi_m(Y), q\rangle \cong (\Zmod{q})[X]\large/\langle
\bar{\Phi}_m(X) \rangle \\
R_p &:= \ZZ[Y]\large/\langle \Phi_m(Y), p\rangle \cong (\Zmod{p})[X]\large/\langle
\bar{\Phi}_m(X) \rangle.
\end{aligned}
$$

For any polynomial $\vec{y} := \sum_0^{n} a_iY^i \in \ZZ[Y]$ of
arbitrary degree $n$, we define its norm $|\vec{y}|$ as

$$
  \begin{aligned}
  \norm{\cdot} &: \ZZ[Y] \rightarrow \ZZ_{\ge 0} \\
  \norm{\sum_0^{m} a_iY^i} &= \max\{\norm{a_0}, \norm{a_1}, \cdots, \norm{a_n} \}
  \end{aligned}
$$

Similarly, if $\vec{y} \in \ZZ[Y]\large /\langle \Phi_m(Y)\rangle$,
then the norm $|\vec{y}|$ is defined as the maximum value of all the
coefficient of $\vec{y}$.

Let $\vec{y} \in \ZZ[Y]$ and $\bar{\vec{y}}$ be it's image in
$\ZZ[Y]/\langle \Phi(Y) \rangle$. We would like to find a constant
$\gamma \in \ZZ$, such that for all $\vec{y} \in \ZZ[Y]$

Let $\vec{\chi}$ be a "narrow" distribution defined over the
polynomial quotient ring $R$ and let $\bar{\vec{\chi}}$ denote the
distribution over the finite ring $R_q$ obtained by sampling
$\vec{e}(X) \xleftarrow{\vec{\chi}} R$ and reducing $\vec{e}(X)$
modulo $q$. Let $B$ be an integer such that $B\cdot p \ll q$ and
$\prob\left[|\vec{e}(X)| > B : \vec{e}(X)
\xleftarrow{\bar{\vec{\chi}}} R_q\right] < \epsilon$, i.e., the
coefficient of any sampled error term $\vec{e}(X)$ is bounded by $B$
with high probability.

### Decisional Ring-LWE assumption

Recall that under _decisional Ring-LWE assumption_, one is given two
oracles $\Xi$ and $\Gamma$, both of which produce samples of the
form $(\vec{a}_i(X), \vec{b}_i(X)) \in R_q\times R_q$. In both
$\Xi$ and $\Gamma$, $\vec{a}_i(X)$ is sampled uniformly at random,
but $\vec{b}_i(X)$ is computed differently as

- $\vec{b}_i(X) \xleftarrow{\$} R_q$ is sampled uniformly at random
  by one of $\Xi$ or $\Gamma$, while
- $\vec{b}_i(X) = \vec{a}_i(X)\vec{s}(X) + \vec{e}_i(X)$, where
  $\vec{s}(X) \xleftarrow{\$} R_q$ and $\vec{e}_i(X)
  \xleftarrow{\bar{\vec{\chi}}} R_q$, by the other oracle.

The decisional (Ring)-LWE assumption states that no polynomial time
(quantum) adversary can distinguish between $\Xi$ and $\Gamma$ using
$\poly{n}$ samples. In other words, Ring-LWE samples are
pseudorandom.

**Notation**: From now on, we write polynomials without the
indeterminate $X$, i.e, $\vec{a}_i(X)$ is simply written
$\vec{a}_i$, etc.

### Symmetric-Key encryption from Ring-LWE

Building a _semantically secure_ secret-key encryption scheme from
any pseudorandom sequence defined over a finite field (or ring) is
almost immediate: Just add the plaintext to a pseudorandom sample
(i.e., compute the one-time-pad equivalent in the appropriate
field). At a high level, this is semantically secure because in any
ring, the addition operation forms a group which defines a
permutation over the elements of the ring. Therefore, if $\rho
\xleftarrow{\$} R_q$ is a (pseudo) random element (not known to the
adversary), then for all $x, y_1, y_2 \in R_q$, $\prob[x + \rho =
y_1]$ $= \prob[y_1 - x = \rho]$ $= \frac{1}{|R_q|}$ $= \prob[x +
\rho = y_2]$. This proof can be made more precise using hybrid
argument, but we don't need it.

In the context of Ring-LWE, for plaintext $m \in \range{p} \subseteq \ZZ$,
secret key $\vec{s} \xleftarrow{\$} R_q$, and error $\vec{e}
\xleftarrow{\chi} R$, the encryption and decryption can be defined
as:

$$
\begin{aligned}
\enc(\vec{s}, m) = \vec{c} &:= (\vec{a},\vec{b})\;\text{where}\\
\vec{a} & \xleftarrow{\$} R_q\\
\vec{b} &:= \lift{\vec{a}\cdot\vec{s}}_q +
  p\vec{e} + m\;(\text{mod}\, q) & \in R_q
\end{aligned}
$$

and given ciphertext $\vec{c} \in R_q\times R_q$  and access to the
secret key $\vec{s}$, one can decrypt $\vec{c} = (\vec{a}, \vec{b})$
as:

$$
\begin{aligned}
\dec(\vec{s}, (\vec{a}, \vec{b})) = m &:= \underbrace{\lift{\vec{b}
- \vec{a}\cdot\vec{s}}_q}_{\in R}\;(\text{mod}\, p) & \in \range{p}
\end{aligned}
$$

???+ example

    Let $m = 8, q = 1024, p = 8$ and $B = 20.$ To keep things
    manageable in this toy example, we will work with the $8$-th
    cyclotomic polynomial $\Phi_8(X) = X^4 + 1$.

    Let $\vec{\chi}$ be the $4$
    dimensional discrete gaussian distribution over $\ZZ$ with
    standard deviation $2$ (so the probability of sampling a value
    greater than $10$ times the standard deviation, i.e., $B = 20$
    is miniscule). Also, note that $p\cdot B \ll q$ as needed.

    Let $R = \ZZ[Y]/\langle Y^4 + 1 \rangle$ and
    $R_q = (\Zmod{q})[X]/\langle X^4 + 1 \rangle$. We use different
    indeterminates $Y$ and $X$ in $R$ and $R_q$ to emphasize that
    these two are different rings that requires an explicit base-change
    to map elements of one ring to the another.

    Let $\vec{s} := 760X^3 + 272X^2 + 340X + 174 \xleftarrow{\$} R_q$
    be the secret key. Let  $m = 5 \in \range{8}$ be the plaintext we
    want to encrypt. Then, the ciphertext can be computed as:

    $$
      \begin{aligned}
        \vec{a} &= 782X^3 + 630X^2 + 389X + 410 \xleftarrow{\$} R_q \\
        \vec{e} &= 4Y^3 + 2Y^2 - 3Y \xleftarrow{\vec{\chi}} R \\
        \vec{a}\cdot \vec{s} &= 700X^3 + 744X^2 + 958X + 988 \in R_q \\
        \lift{\vec{a}\cdot \vec{s}}_q &= -(324Y^3 + 280Y^2 + 66Y + 36) \in R \\
        \lift{\vec{b}}_q &= \lift{\vec{a}\cdot \vec{s}}_q + p\vec{e} + m \in R      \\
            &= -(324Y^3 + 280Y^2 + 66Y + 36) + 8(4Y^3 + 2Y^2 - 3Y) + 5 \\
            &= -(292Y^3 + 264Y^2 + 90Y + 31) \\
        \vec{b} &= \lift{\vec{b}}_q\;\text{mod}\, q \\
                &= 732X^3 + 760X^2 + 934X + 993 \in Rq \\
        \enc(m) &= (782X^3 + 630X^2 + 389X + 410, 732X^3 + 760X^2 + 934X + 993) \in R_q \times R_q
      \end{aligned}
    $$

    Given the ciphertext $\vec{c} = (\vec{a}, \vec{b}) := (782X^3 + 630X^2 + 389X + 410,
    732X^3 + 760X^2 + 934X + 993)$, we can compute the plaintext as follows

    $$
      \begin{aligned}
        \vec{a}\cdot\vec{s} &= 700X^3 + 744X^2 + 958X + 988 \in R_q \\
        \vec{b} - \vec{a}\cdot\vec{s} &= 32X^3 + 16X^2 + 1000X + 5 \in R_q \\
        \lift{\vec{b} - \vec{a}\cdot\vec{s}}_q &= 32Y^3 + 16Y^2 - 24Y + 5 \in R \\
        \dec(\vec{c}) &= \lift{\vec{b} - \vec{a}\cdot\vec{s}}_q\;(\text{mod}\, p) \in \range{p} \\
                      &= 32Y^3 + 16Y^2 - 24Y + 5\;(\text{mod}\, 8) \in \range{p}  \\
                      &= 5
      \end{aligned}
    $$

Note that the decryption process computes $\vec{b}
-\vec{a}\cdot\vec{s} \in \ZZ[X]/\langle \Phi_m, q \rangle$ and lifts
it to $\ZZ[X]/\langle \Phi_m \rangle$. Usually a modulo reduction
from $\ZZ \mapsto \ZZ_q$ followed by a lift from $\ZZ_q \mapsto \ZZ$
is not an identity operation. However, with high probability,
$p|\vec{e}| \ll q \implies |p\vec{e} + m|$ $\leq (|p\vec{e}| + p)
\ll q$. Therefore, $\lift{\vec{b} -\vec{a}\cdot\vec{s}}_q$ $=
\lift{p\cdot \vec{e}
+ m}_q \stackrel{\small{\textsf{whp}}}{=} p\cdot \vec{e} + m$, and
  correctness follows immediately!

In the special case where $p$ divides $q$, a mod followed by a lift
is always an identity operation, as long as $pB + m < q$. In the
previous example, we chose $p=8$ and $q=1024$, therefore no matter
what value of $\vec{e}$ we had chosen, $\lift{p\vec{e}}_q \equiv
0\;(\text{mod}\; p)$. To see this, let $p\mid q$, say $q = \alpha
p$, and let $e_i$ be the $i$-th coefficient of $\vec{e}$. Let
$\hat{e}_i = \lift{p\cdot e_i}_q \in \ZZ$ be the $i$-th coefficient
of $\lift{p\vec{e}}_q$. That means $\exists \beta \in \ZZ$ such that
$p\cdot e_i = \beta\cdot q + \hat{e}_i$ $\implies p\cdot e_i =
\beta\cdot\alpha\cdot p + \hat{e}_i$ $\implies p \mid \hat{e}_i
\implies p \mid \lift{p\vec{e}}_q.$ However, as we will see later,
if $p\cdot e_0 + m > q$ (because of homomorphic operations) then
$\lift{p\vec{e} + m}_q\;(\text{mod}\; p)$ need not be equal to $m$.

### Public-Key encryption from Ring-LWE

Ron Rothblum in [Rot11][^Rot11] described a generic technique for
converting any (distribution-preserving) symmetric-key
additively-homomorphic encryption scheme into a public-key
additively homomorphic scheme. The basic idea is:

- First use the secret-key to compute **multiple encryptions of
  zeros** and publish these encryptions of zeros _as the public-key_.

- Then, to encrypt a message $m$ _using the public-key_ alone, one
  computes the a subset-sum of encryptions of zeros from the
  public-key to create an one-time-pad, and use it to blind the
  message.

For this public-key encryption scheme to be secure, it's crucial
that the subset-sum of encryptions of zeros preserve the
distribution of ciphertext. ([Rot11] proves something stronger,
which we don't discuss here.) In case of Ring-LWE, thanks to
Leftover Hash Lemma, this requirement is easily satisfied.

BGV uses the above template to achieve public-key encryption. As
noted in the general description of [FHE from tensor
products](./fhe-from-tensoring.md#multiplicative-homomorphism), we
need to use _normalized secret key_ and _normalized
ciphertext_ to make FHE evaluation procedures more tractable, so we
summarize the encryption scheme in the normalized format below:

|               |  Basic public-key encryption from Ring-LWE |
| --------------|--------------------------------------------------|
| **Setup**     | $\lambda$ := Security parameter <br/><ul><li>$m=O(\lambda)$ $m$-th cyclotomic polynomial</li><li>$n=\phi(m)$ Lattice dimension</li><li>$q=\tilde{O}(n)$ ciphertext modulus</li><li>$p=O(n)$ plaintext modulus</li><li>$B=O(n)$ error spread satisfying $B\cdot p \ll \frac{q}{n\log{q}}$</li><li>$M := n\log(q)$</li><li> $R := \ZZ[Y]/\langle \Phi_m \rangle$</li><li>$R_q := \ZZ_q[X]\langle \bar{\Phi}_m \rangle$, where $\bar{\Phi}_m := \Phi_m\;\text{mod}\,q$</li><li>$\vec{\chi}$: error distribution over $\ZZ[X]/\langle \Phi_m \rangle$ such that $\prob\left[ \norm{\vec{x}} > B\; :\; \vec{x} \xleftarrow{\chi} \ZZ[X]/\langle \Phi_m \rangle \right] < \epsilon$</li><li>$\bar{\vec{\chi}}$: error distribution over $\ZZ_q[X]/\langle \bar{\Phi}_m \rangle$ computed by sampling $\vec{x} \xleftarrow{\chi} \ZZ[X]/\langle \Phi_m \rangle$ and returning $\vec{x}\; \text{mod}\, q$</li></ul>|
| **KeyGen**        | <ul> <li>Randomly sample secret polynomial: <br/>$\vec{s}' \xleftarrow{\bar{\chi}} \ZZ_q[X]/\langle \bar{\Phi}_m \rangle$</li><li>Set secret-key as the 2-dimensional column vector $\vec{s} := \begin{pmatrix}1 \\ \vec{s}' \end{pmatrix}$</li><li>Compute public-key as $M \times 2 = n\log(q) \times 2$ matrix<br/>$\vec{p} := \begin{pmatrix}\vec{a}_1\cdot \vec{s} + p\vec{e}_i & {-}\vec{a}_1 \\ \vdots & \vdots \\ \vec{a}_M\cdot \vec{s} + p\vec{e}_M & {-}\vec{a}_M\end{pmatrix} \in \left(\ZZ_q[X]/\langle \bar{\Phi}_m\rangle\right)^{M\times 2}$<br/>where $\vec{a}_i \xleftarrow{\$} \ZZ_q[X]/\langle \bar{\Phi}_m \rangle$ and $\vec{e}_i \xleftarrow{\bar{\chi}} \ZZ_q[X]/ \langle \bar{\Phi}_m \rangle$ </li></ul> |
| **Encryption**    | <ul><li>Sample $\vec{r} \xleftarrow{\$} \{0, 1\} \subseteq \ZZ^M$, i.e., a random $n\log(q)$ dimensional vector of $0$s and $1$s</li><li>Compute $\vec{c} = \enc(m, \vec{p}) := \vec{p}^T\cdot \vec{r} + \begin{pmatrix} m \\ 0\end{pmatrix} \in R_q^2$</li></ul> |
| **Decryption**    | <ul><li>$\dec(\vec{s}, \vec{c}) = \lift{\inner{\vec{c}}{\vec{s}}}_q\;(\text{mod}\,p)$</li></ul>|

It should be noted that since each encryption involves subset sum of
encryptions of zeros, the modulus $q$ should be sufficiently large
to ensure that decryption succeeds with high probability.

## Homomorphic Operations

As described in [FHE from tensor
products](./fhe-from-tensoring.md#multiplicative-homomorphism), the
secret to achieving homomorphic evaluation lies in maintain the
following invariant throughout the computation:

$$
  \begin{equation}
  \label{bgv:pt-ct-invariant}
  p\cdot\vec{e} + m = \inner{\vec{c}}{\vec{s}}
  \end{equation}
$$

where $\vec{c}$ and $\vec{s}$ are normalized ciphertext and
secret-key respectively. Without the error term $p\vec{e}$, both
$\eval_+$ and $\eval_\times$ are easily achieved. We now analyze
$\eval_+$ and $\eval_{\times}$ in the presence of error terms.

### BGV Homomorphic Addition

Let $\vec{c}_1$ and $\vec{c}_2$ be the ciphertexts corresponding to
plaintext $m_1$ and $m_2$ respectively.
[Recall](./fhe-from-tensoring.md#additive-homomorphism) that
homomorphic addition is achieved by simply adding the ciphertext
vectors, i.e.,

$$
  \eval_+(\vec{c}_1, \vec{c}_2) = \vec{c}_1 + \vec{c}_2.
$$

In terms of BGV invariant, this means:

$$
p\cdot(\vec{e}_1 + \vec{e}_2) + (m_1 + m_2) = \inner{\vec{c}_1
+ \vec{c}_2}{\vec{s}}.
$$

To ensure that this ciphertext can be decrypted correctly, the
following inequality must hold after $l$ levels of additions:

$$
\begin{aligned}
 \norm{p\left(\sum_{i=0}^{l}e_i\right) + \sum_{i=0}^{l}m_i} &\ll q
\end{aligned}
$$

which can be easily satisfied if $q \gg 2lp(B + 1)$. Depending upon
the maximum additive depth $L$ of the circuit, one can select
parameters $q$ and $p$ such the above constraints are satisfied.

### BGV Homomorphic Multiplication

[Recall](./fhe-from-tensoring.md#multiplicative-homomorphism) that
if $\vec{c}_1$ and $\vec{c}_2$ are two ciphertexts, such that

$$
\begin{aligned}
p\vec{e}_1 + m_1 &= \inner{\vec{c}_1}{\vec{s}} \\
p\vec{e}_2 + m_2 &= \inner{\vec{c}_2}{\vec{s}}
\end{aligned}
$$

then

$$
\begin{aligned}
(p\vec{e}_1 + m_1)(p\vec{e}_2 + m_2) &=
\inner{\vec{c}_1}{\vec{s}}\inner{\vec{c}_2}{\vec{s}} =
\inner{\vec{c}_1\otimes \vec{c}_2}{\vec{s}\otimes \vec{s}} \\
& \implies \\
 p(p\vec{e}_1\vec{e}_2 + m_1\vec{e}_2 + m_2\vec{e}_1) + m_1m_2&=
\inner{\vec{c}_1\otimes \vec{c}_2}{\vec{s}\otimes \vec{s}}
\end{aligned}
$$

and the product ciphertext $\vec{c}_3$ is the tensor product
$\vec{c}_1\otimes\vec{c}_2$ under the new secret key
$\vec{s}\otimes\vec{s}$. If we write $\vec{c}_3$ in terms of the
underlying LWE samples, which is expected to be of the form
$\begin{pmatrix}\vec{a}_3\cdot(\vec{s}\otimes\vec{s}) + p\vec{e}_3 +
m_1m_2\\
-\vec{a}_3 \end{pmatrix}$ -- because that's what the decryption
algorithm operates on, then the noise term:

$$
  p\vec{e}_3 := p\vec{e}_1\vec{e}_2 + m_1\vec{e}_2 + m_2\vec{e}_1.
$$

which can best be bounded by:

$$
\begin{aligned}
\norm{\vec{e}_3} &= \norm{p\vec{e}_1\vec{e}_2 + m_1\vec{e}_2 +
m_2\vec{e}_1} \\
 &\leq p\norm{\vec{e}_1\vec{e}_2} + m_1\norm{\vec{e}_2} + m_2\norm{\vec{e}_1}
\end{aligned}
$$

There are two *practical* problems with this ciphertext: First,
the ciphertext dimension doubles[^double-diemnsion] with every
mulitplication, and second, the noise term gets multiplied by the
$p$.

#### Relinearization
As discussed in the [learning without
errors](fhe-from-tensoring.md#relinearization) settings, the trick
to change the cipher text dimension from $n$ to $m$ is to:

1. First, sample a new secret-key $\vec{t} \in R_q^{m}$ uniformly at
   random and use this new key to publish "encryptions" of each
   component of the old key $\vec{s}$.

2. Use the encryptions of the old key and the old ciphertext to
   generate a ciphertext that preserves the inner-product invariant.

We proceed with the strategy we used in the [learning without
errors](fhe-from-tensoring.md#relinearization) setting, but add the
error terms to make the scheme secure, and also understand new
problems it creates.

Suppose $\bar{\vec{s}} \otimes \bar{\vec{s}}= \begin{bmatrix} 1 &
s_1 & \cdots & s_\ell \end{bmatrix} \in R_q^{\ell+1}$ is the
normalized secret key and $\vec{c}_3 \in R_q^{\ell+1}$ is the
corresponding ciphertext $\vec{c}_3$ after computing the tensor
products. Let $\vec{t} \in R_q^m$ be the new raw secret-key. Then
the first pre-processing step (which must be carried out at the time
of key-generation) is to compute encryptions of $s_i$ using the new
key $\vec{t} \in R_q^m$, i.e., compute $\ell+1$ ciphertexts

$$
  \begin{aligned}
  \psi_0 &= \inner{\vec{d}_0}{\vec{t}} + 1   + p\vec{e}_0\\
  \psi_1 &= \inner{\vec{d}_1}{\vec{t}} + s_1 + p\vec{e}_1\\
  \psi_2 &= \inner{\vec{d}_2}{\vec{t}} + s_2 + p\vec{e}_2\\
  &\cdots \\
  \psi_\ell &= \inner{\vec{d}_\ell}{\vec{t}} + s_\ell + p\vec{e}_\ell\\
  \end{aligned}
$$

where $\vec{d}_i \in R_q^{m}$ and $\vec{e}_i \xleftarrow{\bar{\chi}} R_q$.
These $\ell+1$ ciphertexts and the corresponding $\vec{d}_i$s can be
represented as normalized ciphertexts in an $(\ell+1) \times (m+1)$
matrix $\mathbf{B}$ called relinearization matrix:

$$
  \begin{equation}
  \mathbf{B} := \begin{pmatrix}
    \psi_0 \concat {-\vec{d}_0} \\
    \psi_1 \concat {-\vec{d}_1} \\
    \psi_2 \concat {-\vec{d}_2} \\
    \cdots \\
    \psi_n \concat {-\vec{d}_\ell} \\
  \end{pmatrix} \in R_q^{(\ell+1)\times (\ell+1)}.
  \label{bgv:relinearization-matrix}
  \end{equation}
$$

If $\vec{\xi} = \begin{bmatrix} \vec{e}_0 & \cdots & \vec{e}_\ell
\end{bmatrix}$, then

$$
\begin{equation}
\begin{aligned}
\bar{\vec{s}} \otimes \bar{\vec{s}} &= \mathbf{B}\cdot \bar{\vec{t}} - \vec{\xi}
\end{aligned}
\label{bgv:key-transformation}
\end{equation}
$$

and for the ciphertext $\vec{c}_3$, encrypted under secret-key
$\bar{\vec{s}}\otimes \bar{\vec{s}}$, the following holds:

$$
  \begin{aligned}
  p\cdot\vec{e}_3 + m_1m_2 = \inner{\vec{c}_3}{\bar{\vec{s}}\otimes \bar{\vec{s}}} &= \inner{\vec{c}_3}{\left(\mathbf{B}\cdot  \bar{\vec{t}} - \xi \right)} &
  (\text{by}\;\ref{bgv:key-transformation})\\
  &= \inner{\vec{c}_3}{\mathbf{B}\cdot \bar{\vec{t}}} -
  \inner{\vec{c}_3}{\xi} & (\text{by bi-linearity}) \\
  & \implies & \\
  p\cdot \vec{e}_3 + m_1m_2 + \inner{\vec{c}_3}{\xi} &= \inner{\mathbf{B}^T\cdot \vec{c}}{\bar{\vec{t}}} &
  \end{aligned}
$$

Therefore, $\mathbf{B}^T\cdot \vec{c}$ is a valid, _decryptable_
ciphertext for message $m_1m_2$ -- encrypted under a different
secret-key $\bar{\vec{t}}$ of arbitrary dimension -- provided
$\norm{\inner{\vec{c}_3}{\xi} + p\cdot e} \ll q$. So when is
$\norm{\inner{\vec{c}_3}{\xi} + p\cdot e} \ll q$? Well, never!

The reason $\norm{\inner{\vec{c}_3}{\xi} + p\cdot e}$ is never small
is because the ciphertext $\vec{c}_3$ has large coefficients ($O(q)$)
and therefore $\inner{\vec{c}_3}{\xi}$ is usually the same size as
$q$. Therefore, directly applying relinearization does not work.

#### Bit Decomposition

For relinearization to work, the coefficients of $\vec{c}_3$ must be
small. BGV once again exploits the bi-linearity of inner product to
transform the ciphertext and the secret key to have small ciphertext
coefficients.

Since

$$
\inner{\vec{c}}{\vec{\bar{s}}} = \sum_j c_j\cdot
s_j = \sum_j \sum_{k=0}^{\log_p(q)} \frac{c_j}{p^k}\cdot (p^ks_j)
$$

if we write $\vec{c}$ as a dimension $n\times\ceil{\log_p(q)}$
matrix where each column is a component of base-$p$ representation,
and write $\vec{\bar{s}}$ as a dimension $n\times\ceil{\log_p(q)}$
matrix where each column is multiplied by an appropriate power of
$p$, then the inner product of these matrices, is the same as the
inner product $\inner{\vec{c}}{\vec{\bar{s}}}$.

More concretely, if

$$
\vec{c} = \sum_{k=0}^{\floor{\log_p(q)}} c_k\cdot p^k \in R^{n};\quad c_k \in \left(\lift{R/\langle p \rangle}_q\right) ^n
$$

then, we define

$$
  \mathbf{C} := [c_0,c_1,c_2,\cdots, p^{\floor{\log_p(q)}}] \in R_q^{n\times \ceil{\log_p(q)}}
$$

and

$$
  \begin{align*}
  \mathbf{S} &:= [\bar{\vec{s}},p\bar{\vec{s}},p^2\bar{\vec{s}},\cdots, p^{\floor{\log_p(q)}}\bar{\vec{s}}]  \in R_q^{n\times \ceil{\log_p(q)}} \\
    &= \vec{s} \cdot \begin{pmatrix} 1 & p & p^2 & \cdots & p^\floor{\log_p(q)}\end{pmatrix} =: \vec{s} \cdot \vec{P}^T
  \end{align*}
$$

where $\vec{P}$ is the column vector of powers of $p$. Then, the inner product of $\mathbf{C}$ and $\mathbf{S}$ is defined as

$$
\begin{align*}
\inner{\mathbf{C}}{\mathbf{S}} &:= \text{tr}_q (\mathbf{S}^T \mathbf{C}) \\
  & = \text{tr}_q \left( (\vec{s} \cdot \vec{P}^T) \right )^T \mathbf{C} \\
  & = \text{tr}_q \left( \vec{P} \cdot \vec{s}^T  \mathbf{C} \right)      \\
  &= \sum_k p^k \inner{\vec{s}}{c_k} \\
  &= \inner{s}{\sum_k p^k \cdot c_k} \\
  &= \inner{\vec{c}}{\vec{s}}
\end{align*}
$$

Therefore, the new relinearization step is as follows:

1. Instead of encrypting each component of secret key $\vec{s}$ with
   a new key $\vec{t}$, encrypt each component of the key matrix
   $\mathbf{S}$. This matrix is the new analog of relinearization
   matrix $\mathbf{B}$ defined in
   Eq-$\ref{bgv:relinearization-matrix}$). The size of the new
   relinearization matrix is bigger by a _factor_ of
   $\ceil{\log_p(q)}$ -- which can be significant if $q$ is large.

2. To perform relinearization, given the ciphertext $\vec{c}$, do a
   base $p$ decomposition of $\vec{c}$ and compute the new inner
   product of the bit-decomposed cipher text. Since the cipher text
   now has small coefficients, which range in both positive and
   negative value, the inner product $\inner{\vec{C}}{\xi}$ is small
   compared to $\inner{\vec{c}}{\xi}$.


The following example demonstrates this situation

???+ example

    As before, we will work with $m = 8, q = 1024, p = 8$ and
    $B = 20$ where the Ring-LWE samples are taken from
    $\ZZ[X]/\langle X^4 + 1\rangle$. We choose the standard deviation
    of $\chi$ to be $2$.

    #### Key Generation and Pre-computation

    Using sagemath, the following secret keys are generated

    $$
    \begin{align*}
    \vec{s} &= 3X^3 - 2X^2 + 2X + 1 \\
    \vec{t} &= X^3 + X^2 + 2
    \end{align*}
    $$

    Since $q = 1024$ and $p = 8$, $\floor{\log_8(1024)} = 3$. Therefore

    $$
      \mathbf{S} := \begin{pmatrix} 1 & 8 & 64 & 512 \\
                      \vec{s} & 8\vec{s} & 64\vec{s} & 512 \vec{s}
                    \end{pmatrix}
    $$

    To compute the relinearization matrix, we will serialize
    $\mathbb{S}$ into a column vector as

    $$
      \mathbf{S}' := \begin{pmatrix} 1 \\
                      \vec{s} \\
                      8 \\
                      8\vec{s} \\
                      16 \\
                      16\vec{s} \\
                      32 \\
                      32\vec{s} \\
                    \end{pmatrix}
    $$

    and compute $\mathbf{B}$ normally.

### Modulus Switching

Suppose $\vec{c}$ is a valid encryption of $m$ under the secret key
$\vec{s}$ modulo $q$. Furthermore, suppose the secret key $\vec{s}$
is also drawn from the error distribution. Then, for all
integers $q'$,

$$
  \inner{\frac{q'}{q}\vec{c}}{\bar{\vec{s}}} = \frac{q'}{q}\inner{\vec{c}}{\bar{\vec{s}}} = m\frac{q'}{q} + pe\frac{q'}{q}
$$

In other words, scaling the ciphertext alone scales the message and
the _error term_ by the same ratio. Furthermore, if one ensures that
the rounding $\lfloor\frac{q'}{q}\rceil\vec{c}$  is done in such a
way that $\lfloor\frac{q'}{q}\rceil\vec{c} \equiv \vec{c} \mod p$,
then it will preserve that plaintext message.

This process of scaling the ciphertext to generated a new ciphertext
that has scaled down error term is called modulus switching.
**Warning**: While the cipher text is getting scaled down, it's
crucial to enforce the requirement to round the vector such that
$\lfloor\frac{q'}{q}\rceil\vec{c} \equiv \vec{c} \mod p$. With this,
the ciphertext will not decrypt correctly.


[^double-diemnsion]: You may be wondering why doesn't this
  exponential growth in ciphertext size invalidate the compactness
  requirement? That's because this is a leveled scheme, so
  **theoretically**, the output ciphertext size is bounded by the
  circuit depth.

[^BGV]: Z. Brakerski, C. Gentry and V. Vaikuntanathan,
  [(Leveled) Fully homomorphic encryption without bootstrapping](https://ia.cr/2011/277).
  In _Innovations in Theoretical Computer Science_, 2012.

[^Reg05]: O. Regev. [On lattices, learning with errors, random linear
    codes, and
    cryptography](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.863.6537&rep=rep1&type=pdf).
    In  J. ACM, 56(6):1â€“40, 2009. Preliminary version in STOC 2005.

[^Reg10]: O. Regev. [The learning with errors
    problem](https://cims.nyu.edu/~regev/papers/lwesurvey.pdf)
    (invited
    survey). In IEEE Conference on Computational Complexity, pages
    191â€“204. 2010.

[^HS20]: S. Halevi and V. Shoup, [Design and implementation of
    HElib: a homomorphic encryption
    library](https://eprint.iacr.org/2020/1481), In Cryptology
    ePrint Archive, Report 2020/1481, 2020.


[^HS21]: S. Halevi and V. Shoup, [Bootstrapping for
    HElib](https://www.shoup.net/papers/boot.pdf). In Journal of
    Cryptology, Vol. 34, No. 7, 2021.

[^Rot11]: R. Rothblum, [Homomorphic Encryption: From Private-Key to
    Public-Key](https://www.iacr.org/archive/tcc2011/65970216/65970216.pdf).
    In Theory of Cryptography, Page 219--234, 2011.

